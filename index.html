<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>PDF Editor — Prototype</title>
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
<link href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap-icons/1.11.3/font/bootstrap-icons.min.css" rel="stylesheet">
<style>
  body{background:#0b1220;color:#eaf4fb;font-family:Inter,Arial;margin:0;padding:0}
  .topbar{background:#071026;padding:12px 18px;display:flex;align-items:center;justify-content:space-between;border-bottom:1px solid rgba(255,255,255,0.03)}
  .btn-ghost{background:transparent;border:1px solid rgba(255,255,255,0.06);color:#eaf4fb}
  .container-main{display:flex;gap:12px;padding:18px}
  .left{width:220px}
  .center{flex:1;min-height:70vh;background:#0f1b2a;padding:12px;border-radius:8px}
  .right{width:320px}
  #pdfPreview{background:#fff;padding:14px;border-radius:8px;color:#000;display:flex;flex-wrap:wrap;gap:12px;align-items:flex-start}
  .page-wrap{position:relative;border:1px solid #ddd;background:#fff;border-radius:6px;overflow:visible}
  .base-canvas{display:block}
  .overlay{position:absolute;left:0;top:0;right:0;bottom:0;pointer-events:auto}
  .text-box{position:absolute;padding:6px;border:1px dashed rgba(0,0,0,0.12);background:transparent;color:#000;min-width:60px;min-height:20px}
  .img-box{position:absolute;border:1px solid rgba(0,0,0,0.06);background-size:cover;background-position:center}
  .dragger{position:absolute;right:6px;bottom:6px;width:12px;height:12px;background:#06b6d4;border-radius:2px;cursor:se-resize}
  .thumb{border:1px solid rgba(255,255,255,0.06);padding:6px;margin-bottom:8px;background:transparent;cursor:pointer}
  .small-muted{color:#9aa6b2;font-size:13px}
</style>
</head>
<body>
  <div class="topbar">
    <div style="display:flex;gap:12px;align-items:center">
      <strong>PDF Prototype</strong>
      <div class="small-muted">— Client-side visual editor</div>
    </div>
    <div style="display:flex;gap:8px;align-items:center">
      <input id="pdfFile" type="file" accept="application/pdf" class="form-control form-control-sm" style="width:260px">
      <button id="savePdfBtn" class="btn btn-success btn-sm">Save PDF</button>
    </div>
  </div>

  <div class="container-main">
    <div class="left">
      <div class="mb-2"><button id="toolSelect" class="btn btn-ghost btn-sm w-100">Select / Move</button></div>
      <div class="mb-2"><button id="toolText" class="btn btn-ghost btn-sm w-100">Add Text</button></div>
      <div class="mb-2"><button id="toolImage" class="btn btn-ghost btn-sm w-100">Add Image</button></div>
      <div class="mb-2"><button id="toolBrush" class="btn btn-ghost btn-sm w-100">Brush</button></div>
      <div class="mb-2"><button id="toolEraser" class="btn btn-ghost btn-sm w-100">Eraser</button></div>
      <hr style="border-color:rgba(255,255,255,0.03)">
      <div class="small-muted mb-2">Thumbnails</div>
      <div id="thumbs"></div>
    </div>

    <div class="center">
      <div id="pdfPreview">No PDF loaded — upload a PDF</div>
    </div>

    <div class="right">
      <div class="mb-2"><label class="small-muted">Font size</label><input id="fontSize" type="number" value="18" class="form-control form-control-sm"></div>
      <div class="mb-2"><label class="small-muted">Color</label><input id="colorPicker" type="color" value="#000000" class="form-control form-control-sm" style="height:34px"></div>
      <div class="mb-2"><label class="small-muted">Brush size</label><input id="brushSize" type="range" min="1" max="40" value="4" class="form-range"></div>
      <div class="mt-3"><button id="undoBtn" class="btn btn-ghost btn-sm w-100">Undo</button></div>
      <div class="mt-2"><button id="redoBtn" class="btn btn-ghost btn-sm w-100">Redo</button></div>
    </div>
  </div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
<script src="https://unpkg.com/pdf-lib/dist/pdf-lib.min.js"></script>

<script>
/* Simple prototype JS */
const $ = id => document.getElementById(id);
let pages = []; // {canvas, draw, overlay, wrap, annotations}
let mode = 'select';
let undoStack = [], redoStack = [];

$('toolSelect').onclick = ()=> setMode('select');
$('toolText').onclick = ()=> setMode('text');
$('toolImage').onclick = ()=> setMode('image');
$('toolBrush').onclick = ()=> setMode('brush');
$('toolEraser').onclick = ()=> setMode('eraser');

function setMode(m){
  mode = m;
  document.querySelectorAll('.btn-ghost').forEach(b=>b.classList.remove('active'));
  if(m==='text') $('toolText').classList.add('active');
  if(m==='image') $('toolImage').classList.add('active');
  if(m==='brush') $('toolBrush').classList.add('active');
  if(m==='eraser') $('toolEraser').classList.add('active');
}

/* pdf.js worker */
if(window.pdfjsLib) pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';

/* Load PDF */
$('pdfFile').addEventListener('change', async (e)=>{
  const f = e.target.files && e.target.files[0]; if(!f) return;
  const buf = await f.arrayBuffer();
  renderPdf(buf);
});

async function renderPdf(buffer){
  pages = [];
  $('pdfPreview').innerHTML = '';
  $('thumbs').innerHTML = '';
  if(!window.pdfjsLib){ $('pdfPreview').textContent = 'pdf.js not available'; return; }
  const loading = pdfjsLib.getDocument({data:buffer}); const pdf = await loading.promise;
  for(let i=1;i<=pdf.numPages;i++){
    const pg = await pdf.getPage(i);
    const viewport = pg.getViewport({scale:1});
    const targetW = Math.min(900, window.innerWidth - 360);
    const scale = Math.min(1.3, targetW / viewport.width);
    const rvp = pg.getViewport({scale});
    const canvas = document.createElement('canvas'); const ctx = canvas.getContext('2d');
    canvas.width = rvp.width; canvas.height = rvp.height;
    await pg.render({canvasContext:ctx, viewport:rvp}).promise;

    const wrap = document.createElement('div'); wrap.className = 'page-wrap';
    wrap.style.width = canvas.width + 'px'; wrap.style.height = canvas.height + 'px';
    const overlay = document.createElement('div'); overlay.className = 'overlay'; overlay.style.width = canvas.width + 'px'; overlay.style.height = canvas.height + 'px';
    const draw = document.createElement('canvas'); draw.width = canvas.width; draw.height = canvas.height; draw.style.position='absolute'; draw.style.left='0'; draw.style.top='0';
    wrap.appendChild(canvas); wrap.appendChild(overlay); wrap.appendChild(draw);
    $('pdfPreview').appendChild(wrap);

    const obj = { canvas, ctx, draw, drawCtx: draw.getContext('2d'), overlay, wrap, annotations:{texts:[],images:[],strokes:[]} };
    pages.push(obj);

    // thumbnail
    const thumb = document.createElement('div'); thumb.className='thumb'; thumb.textContent = 'Page '+i; thumb.onclick = ()=> { wrap.scrollIntoView({behavior:'smooth',block:'center'}); };
    $('thumbs').appendChild(thumb);

    // overlay click
    overlay.addEventListener('pointerdown', (ev)=>{
      const rect = overlay.getBoundingClientRect();
      const x = ev.clientX - rect.left, y = ev.clientY - rect.top;
      if(mode==='text') createTextBox(obj,x,y);
      else if(mode==='image') promptImageThenPlace(obj,x,y);
    });

    setupDrawing(obj);
  }
  pushUndo();
}

/* create text box */
function createTextBox(pObj,x,y){
  const el = document.createElement('div'); el.className='text-box'; el.contentEditable = true;
  el.style.left = x+'px'; el.style.top = y+'px'; el.style.fontSize = (parseInt($('fontSize').value)||18)+'px'; el.style.color = $('colorPicker').value;
  el.innerText = 'Text';
  pObj.overlay.appendChild(el);
  const dragger = document.createElement('div'); dragger.className='dragger'; el.appendChild(dragger);
  makeDraggable(el);
  dragger.addEventListener('pointerdown', startResize.bind(null,el));
  pObj.annotations.texts.push({el});
  el.addEventListener('input', pushUndo);
  pushUndo();
}

/* image place */
function promptImageThenPlace(pObj,x,y){
  const inp = document.createElement('input'); inp.type='file'; inp.accept='image/*';
  inp.onchange = ()=>{
    const f = inp.files && inp.files[0]; if(!f) return;
    const r = new FileReader(); r.onload = (ev)=>{
      const img = new Image(); img.onload = ()=>{
        const wrap = document.createElement('div'); wrap.className='img-box'; wrap.style.left = x+'px'; wrap.style.top = y+'px';
        const w = Math.min(240, img.width); const h = Math.round(img.height*(w/img.width));
        wrap.style.width = w+'px'; wrap.style.height = h+'px'; wrap.style.backgroundImage = `url(${ev.target.result})`;
        pObj.overlay.appendChild(wrap);
        const dragger = document.createElement('div'); dragger.className='dragger'; wrap.appendChild(dragger);
        makeDraggable(wrap); dragger.addEventListener('pointerdown', startResize.bind(null,wrap));
        pObj.annotations.images.push({el:wrap, src: ev.target.result});
        pushUndo();
      }; img.src = ev.target.result;
    }; r.readAsDataURL(f);
  };
  inp.click();
}

/* simple draggable */
function makeDraggable(el){
  el.style.position='absolute';
  let dragging=false, ox=0, oy=0;
  el.addEventListener('pointerdown',(e)=>{ if(e.target.classList.contains('dragger')) return; dragging=true; const r=el.getBoundingClientRect(); ox=e.clientX-r.left; oy=e.clientY-r.top; el.setPointerCapture && el.setPointerCapture(e.pointerId); });
  el.addEventListener('pointermove',(e)=>{ if(!dragging) return; try{ el.style.left = (e.clientX-ox)+'px'; el.style.top = (e.clientY-oy)+'px'; }catch(err){} });
  el.addEventListener('pointerup',()=>{ if(dragging){ dragging=false; pushUndo(); } });
}

/* resize */
function startResize(target, ev){
  ev.stopPropagation();
  const startW = target.clientWidth, startH = target.clientHeight, startX = ev.clientX, startY = ev.clientY;
  function onMove(e){ const dx = e.clientX - startX, dy = e.clientY - startY; target.style.width = Math.max(24, startW + dx) + 'px'; target.style.height = Math.max(18, startH + dy) + 'px'; }
  function onUp(){ document.removeEventListener('pointermove', onMove); document.removeEventListener('pointerup', onUp); pushUndo(); }
  document.addEventListener('pointermove', onMove); document.addEventListener('pointerup', onUp);
}

/* drawing */
function setupDrawing(pObj){
  const canvas = pObj.draw; const ctx = pObj.drawCtx; let drawing=false, last={x:0,y:0}, stroke=[];
  canvas.addEventListener('pointerdown',(e)=>{ if(mode!=='brush' && mode!=='eraser') return; drawing=true; const r=canvas.getBoundingClientRect(); last={x:e.clientX-r.left,y:e.clientY-r.top}; stroke=[{x:last.x,y:last.y}]; canvas.setPointerCapture && canvas.setPointerCapture(e.pointerId); });
  canvas.addEventListener('pointermove',(e)=>{ if(!drawing) return; const r=canvas.getBoundingClientRect(); const x=e.clientX-r.left, y=e.clientY-r.top; if(mode==='brush'){ ctx.strokeStyle = $('colorPicker').value; ctx.lineWidth = Math.max(1, parseInt($('brushSize').value)); ctx.lineCap='round'; ctx.beginPath(); ctx.moveTo(last.x,last.y); ctx.lineTo(x,y); ctx.stroke(); stroke.push({x,y}); } else if(mode==='eraser'){ ctx.clearRect(x-8,y-8,16,16); } last={x,y}; });
  canvas.addEventListener('pointerup',()=>{ if(!drawing) return; drawing=false; if(stroke.length){ pObj.annotations.strokes.push({points: stroke, color: $('colorPicker').value, width: parseInt($('brushSize').value)}); pushUndo(); } });
}

/* undo/redo (basic serialization of annotations only) */
function snapshot(){
  try{
    return JSON.stringify(pages.map(p=>({
      annotations:{
        texts:p.annotations.texts.map(t=>({left:t.el.style.left,top:t.el.style.top,html:t.el.innerHTML, size: t.el.style.fontSize, color: t.el.style.color})),
        images:p.annotations.images.map(i=>({left:i.el.style.left,top:i.el.style.top,width:i.el.style.width,height:i.el.style.height,src:i.src})),
        strokes:p.annotations.strokes
      }
    })));
  }catch(e){ return '[]'; }
}
function restore(snap){
  try{
    const data = JSON.parse(snap);
    data.forEach((pd, idx)=>{ if(!pages[idx]) return; // remove overlays
      pages[idx].overlay.querySelectorAll('.text-box,.img-box').forEach(n=>n.remove()); pages[idx].drawCtx.clearRect(0,0,pages[idx].draw.width,pages[idx].draw.height);
      pages[idx].annotations = {texts:[],images:[],strokes:[]};
      (pd.annotations.texts||[]).forEach(t=>{ const el = document.createElement('div'); el.className='text-box'; el.contentEditable=true; el.style.left=t.left; el.style.top=t.top; el.style.fontSize=t.size||'18px'; el.style.color=t.color||'#000'; el.innerHTML = t.html||''; pages[idx].overlay.appendChild(el); const dragger=document.createElement('div'); dragger.className='dragger'; el.appendChild(dragger); makeDraggable(el); dragger.addEventListener('pointerdown', startResize.bind(null, el)); pages[idx].annotations.texts.push({el}); });
      (pd.annotations.images||[]).forEach(i=>{ const wrap = document.createElement('div'); wrap.className='img-box'; wrap.style.left=i.left; wrap.style.top=i.top; wrap.style.width=i.width; wrap.style.height=i.height; wrap.style.backgroundImage=`url(${i.src})`; pages[idx].overlay.appendChild(wrap); const dragger=document.createElement('div'); dragger.className='dragger'; wrap.appendChild(dragger); makeDraggable(wrap); dragger.addEventListener('pointerdown', startResize.bind(null,wrap)); pages[idx].annotations.images.push({el:wrap,src:i.src}); });
      (pd.annotations.strokes||[]).forEach(s=>{ const ctx = pages[idx].drawCtx; ctx.strokeStyle = s.color||'#000'; ctx.lineWidth = s.width||2; ctx.beginPath(); s.points.forEach((pt,pi)=>{ if(pi===0) ctx.moveTo(pt.x,pt.y); else ctx.lineTo(pt.x,pt.y); }); ctx.stroke(); pages[idx].annotations.strokes.push(s); });
    });
  }catch(e){ console.warn('restore failed', e); }
}
function pushUndo(){ undoStack.push(snapshot()); redoStack = []; }
$('undoBtn').onclick = ()=>{ if(!undoStack.length) return; const s = undoStack.pop(); redoStack.push(snapshot()); restore(s); }
$('redoBtn').onclick = ()=>{ if(!redoStack.length) return; const s = redoStack.pop(); undoStack.push(snapshot()); restore(s); }

/* Save visual PDF using pdf-lib: rasterize each page composite */
$('savePdfBtn').addEventListener('click', async ()=>{
  if(!pages.length) return alert('Load a PDF first');
  try{
    const newDoc = await PDFLib.PDFDocument.create();
    for(const p of pages){
      // compose high-res canvas
      const scale = 2;
      const comp = document.createElement('canvas'); comp.width = p.canvas.width * scale; comp.height = p.canvas.height * scale;
      const cctx = comp.getContext('2d');
      cctx.drawImage(p.canvas, 0, 0, comp.width, comp.height);
      cctx.drawImage(p.draw, 0, 0, comp.width, comp.height);
      // draw text boxes
      for(const t of p.annotations.texts){
        const el = t.el; const left = parseFloat(el.style.left)||0; const top = parseFloat(el.style.top)||0; const fs = parseInt(el.style.fontSize)||18;
        cctx.font = `${fs*scale}px Arial`; cctx.fillStyle = el.style.color||'#000';
        const lines = (el.innerText||'').split('\\n');
        for(let li=0; li<lines.length; li++){
          cctx.fillText(lines[li], left*scale+2, (top + (li*(fs+2)))*scale + fs*scale);
        }
      }
      // draw images
      for(const im of p.annotations.images){
        const el = im.el; const left = parseFloat(el.style.left)||0; const top = parseFloat(el.style.top)||0;
        const w = parseFloat(el.style.width)||100; const h = parseFloat(el.style.height)||100;
        const bg = el.style.backgroundImage || '';
        let url = ''; const s = bg.indexOf('url('); const e = bg.lastIndexOf(')'); if(s!=-1 && e!=-1) { url = bg.substring(s+4,e).replace(/(^['\"]|['\"]$)/g,''); }
        if(url){
          await new Promise(res=>{
            const img = new Image(); img.crossOrigin='anonymous';
            img.onload = ()=>{ cctx.drawImage(img, left*scale, top*scale, w*scale, h*scale); res(); };
            img.onerror = ()=>res();
            img.src = url;
          });
        }
      }
      const blob = await new Promise(r=>comp.toBlob(r,'image/jpeg',0.95));
      const bytes = await blob.arrayBuffer();
      const jpg = await newDoc.embedJpg(bytes);
      const page = newDoc.addPage([jpg.width, jpg.height]);
      page.drawImage(jpg, {x:0,y:0,width:jpg.width,height:jpg.height});
    }
    const pdfBytes = await newDoc.save();
    const blob = new Blob([pdfBytes],{type:'application/pdf'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href=url; a.download='edited.pdf'; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
    alert('Downloaded edited PDF');
  }catch(err){ console.error(err); alert('Save failed: '+err.message); }
});
</script>
</body>
</html>
